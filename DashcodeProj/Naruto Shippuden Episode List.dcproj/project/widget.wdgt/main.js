/* 
 This file was generated by Dashcode.  
 You may edit this file to customize your widget or web page 
 according to the license.txt file included in the project.
 */

var entries;           // Feed contents
var currentEntry;      // Which entry is currently displayed
var lastUpdated = 0;   // Track last refresh time to avoid excessive updates

// Values for feed type in the attributes panel
var DFFeedTypeHTML = 0;
var DFFeedTypeImage = 1;

// Define some namespaces commonly used in feeds
var NS_DC = "http://purl.org/dc/elements/1.1/";
var NS_CONTENT = "http://purl.org/rss/1.0/modules/content/";

var showingDetailView = false;

function refreshFeed()
{
    //var url = attributes.feedURL;
	var url = "http://en.wikipedia.org/wiki/List_of_Naruto:_Shippuden_episodes";
	
    if (url && url.length) {
        url = url.replace(/^(feed:\/\/)/, "");
        if (url.substring(0, 7).toLowerCase() != "http://") {
            url = "http://" + url;
        }
    }
    else {
        showError(dashcode.getLocalizedString("No feed URL supplied."));
        return;
    }

    setDateText(dashcode.getLocalizedString("Loading") + "...");

    var xmlRequest = new XMLHttpRequest();
    xmlRequest.overrideMimeType("text/xml");
    xmlRequest.open("GET", url, true);

    xmlRequest.onreadystatechange = function () {
        if (xmlRequest.readyState == 4) {
			processHTMLWikiNaruto(xmlRequest.responseXML);
        }
    };

    xmlRequest.send(null);
}

function processHTMLWikiNaruto(doc){
	clearEntries();
	
	try{
		if (doc && doc.documentElement) {
			parseWikipediaHTML(doc);
		}
		else {
            throw new Error(dashcode.getLocalizedString("Failed to load a valid feed."));
        }
		if (entries && entries.length) {
			showElement("backButton");
			showElement("forwardButton");
			showEntry(getNextInmediateEntryIndex());
            
            lastUpdated = (new Date).getTime();
    
        }
        else {
            throw new Error("Feed contains no entries.");
        }
	
	
	}catch (ex) {
        showError(ex);
    }
}

function getNextInmediateEntryIndex(){
	var today = new Date();
	today.setHours(0);
	today.setMinutes(0);
	today.setSeconds(0);
	today.setMilliseconds(0);
	
	var i = entries.length;
	do{
		i--;
		var airedDate = new Date(entries[i].epAiredDateJp);
	}while (today < airedDate && i > 0); //Regarding dates: the earlier the smaller
	i++;
	
	return entries.length-1 <= i ? entries.length - 1: i;
	
}

//
// Function: processFeedDocument(document)
// When the feed finishes loading, this function is called to parse it and display the results.
//
// doc: XML document containing the feed
//

function setProgressInProgressBar(percentage){
	var progressBar = document.getElementById("progressBar");
	var progressBarWidth = 213;//progressBar.style.offsetWidth;//.match(/\d+/);//
	document.getElementById("progress").style.width = progressBarWidth*percentage + "px";//(percentage>1.0? 1.0: (percentage<0.0? 0.0:percentage));
}

function parseWikipediaHTML(doc){
	//var html = getFirstElementByTagName(doc, "html"); //why this not work?
	var candidates = doc.getElementsByClassName("vevent"); //for some reason entries in wikipedia has this class name
	var curIndex = 0;
	
	for (var index = 0; index < candidates.length; index++){
		var trElement = candidates[index];
		var tds = trElement.getElementsByTagName("td");
		
		var _epNumber = parseInt(tds[0].innerHTML);
		
		if (_epNumber > curIndex && tds.length > 2){
			//parse tr and add new entry
			curIndex++;
			var _epTitleEn = (tds[1].getElementsByTagName("b"))[0].innerHTML;
			var _epTitleRo = (tds[1].getElementsByTagName("i"))[0].innerHTML;
			var	_epTitleJp = (tds[1].getElementsByTagName("span"))[0].innerHTML;
			var _epAiredDateJp = tds[2].innerHTML;
			
			var subs = tds[3].getElementsByTagName("sup");
			while ( subs.length > 0 ){
				tds[3].removeChild(subs[subs.length-1]);
			}
			var _epAiredDateEn = (tds[3] && tds[3].innerHTML.length > 0)? tds[3].innerHTML : "Not aired yet.";
			
			var entry = { 
				epNumber : _epNumber, 
				epTitleEn : _epTitleEn,
				epTitleRo : _epTitleRo,
				epTitleJp : _epTitleJp,
				epAiredDateJp : _epAiredDateJp,
				epAiredDateEn : _epAiredDateEn
				};
	
			entries.push(entry);
			
		}else{
			break;
		}
	}
	
	
	
}


//
// Function: showEntry(entryNumber)
// Display the given item from the feed.
//
// entryNumber: Number of the item to display.
// entry = { 
//		epNumber : _epNumber, 
//		epTitleEn : _epTitleEn,
//		epTitleRo : _epTitleRo,
//		epTitleJp : _epTitleJp,
//		epAiredDateJp : _epAiredDateJp,
//		epAiredDateEn : _epAiredDateEn
//		};

function showEntry(entryNumber)
{
    currentEntry = entryNumber;
	
	if (entries[entryNumber]) {
        var entry = entries[entryNumber];
		
		var japanese = entry.epTitleJp.replace("(","");
		japanese = japanese.replace("）","");
		japanese = japanese.replace(")","");
		japanese = japanese.replace("）","");
		
		document.getElementById("epNumName").innerText = entry.epNumber + ": " + entry.epTitleEn;
		document.getElementById("epAiredDate").innerText = entry.epAiredDateJp;
		
		var airedDateJp = new Date(entry.epAiredDateJp);
		var today = new Date();
		today.setHours(0);
		today.setMinutes(0);
		today.setSeconds(0);
		today.setMilliseconds(0);
		
		if (airedDateJp == today){
			document.getElementById("epAiredDate").innerText = "Today!!";
		}else if (airedDateJp > today && airedDateJp.getTime() - today.getTime < 3600*24*7) {
			var weekday=new Array(7);
			weekday[0]="Sunday";
			weekday[1]="Monday";
			weekday[2]="Tuesday";
			weekday[3]="Wednesday";
			weekday[4]="Thursday";
			weekday[5]="Friday";
			weekday[6]="Saturday";
			document.getElementById("epAiredDate").innerText = "Next " + weekday[entry.epAiredDateJp.getDay()] + "!";
		}	
			
		
		document.getElementById("epNumber").innerText = entry.epNumber;
		document.getElementById("epTitleEn").innerText = entry.epTitleEn;
		document.getElementById("epTitleRo").innerText = entry.epTitleRo;
		document.getElementById("epTitleJp").innerText = japanese;
		document.getElementById("epAiredDateJp").innerText = entry.epAiredDateJp;
		document.getElementById("epAiredDateEn").innerText = entry.epAiredDateEn;
	}
}

//
// Function: showError(errorHTML)
// Display an error message in the content area.
//
// errorHTML: HTML message to display.
//
function showError(errorHTML)
{
    //setHTMLContent(dashcode.getLocalizedString("Error"), errorHTML);
    setDateText(dashcode.getLocalizedString("Daily Feed"));
    hideElement("forwardButton");
    hideElement("backButton");
}

//
// Function: clearEntries()
// Remove all the stored feed entries.
//
function clearEntries()
{
    entries.length = 0;
}

//
// Function: clearContent()
// Clear the current content area.
//
function clearContent()
{
    var content = document.getElementById("content");
    if (content) {
        while (content.hasChildNodes()) {
            content.removeChild(content.firstChild);
        }
    }
}

//
// Function: setDateText(date)
// Show a date in the status area.
//
// date: Javascript Date to display
//
function setDateText(date)
{
    var dateText = document.getElementById("epAiredDate");
    if (dateText) {
        if (date != null) {
            if (typeof(date) == "string") {
                dateText.innerText = date;
            }
            else {
                var dateStr = date.toLocaleDateString();
                dateText.innerText = dateStr;
            }
        }
        else {
            dateText.innerText = dashcode.getLocalizedString("Daily Feed");
        }
    }
}

//
// Function: getFirstElementByTagName(node, tagName, namespace)
// Returns the first result of getElementsByTagName, or null if none.
//
// node: document node to search
// tagName: tag name to look for
// namespace: option namespace 
//
function getFirstElementByTagName(node, tagName, namespace) {
    var elements;

    if (!namespace) {
        elements = node.getElementsByTagName(tagName);
        if (!elements.length) {
            elements = node.getElementsByTagNameNS("*", tagName);
        }
    }
    else {
        elements = node.getElementsByTagNameNS(namespace, tagName);
    }

    if (elements.length) {
        return elements[0];
    }
    else {
        return null;
    }
}

//
// Function: allData(node)
// Concatenate all the text data of a node's children.
//
// node: DOM element to search for text.
//
// Returns the concatenated text.
//
function allData(node)
{
    var data = "";
    node = node.firstChild;
    if (node) {
        if (node.data) {
            data += node.data;
        }
        while (node = node.nextSibling) {
            if (node.data) {
                data += node.data;
            }
        }
    }

    return data;
}

//
// Function: hideElement(elementId)
// Turn off display for the given element.
//
// elementId: DOM id of the element to hide.
//
function hideElement(elementId)
{
    var element = document.getElementById(elementId);
    if (element) {
        element.style.display = "none";
    }
}

//
// Function: showElement(elementId)
// Turn on display for the given element.
//
// elementId: DOM id of the element to show.
//
function showElement(elementId)
{
    var element = document.getElementById(elementId);
    if (element) {
        element.style.display = "block";
    }
}

//
// Function: setupHandlers()
// Set up Javascript mouseover handlers for the forward and back buttons.
//
function setupHandlers()
{
    var backOver = new Image();
    backOver.src = "Images/backButton_over.png";
    var backDown = new Image();
    backDown.src = "Images/backButton_down.png";
    var forwardOver = new Image();
    forwardOver.src = "Images/forwardButton_over.png";
    var forwardDown = new Image();
    forwardDown.src = "Images/forwardButton_down.png";

    var backButton = document.getElementById("backButton");
    if (backButton) {
        addHilightListeners(backButton, backOver, backDown);
    }

    var forwardButton = document.getElementById("forwardButton");
    if (forwardButton) {
        addHilightListeners(forwardButton, forwardOver, forwardDown);
    }
}

//
// Function: addHilightListeners(element, overImage, downImage)
// Used by setupHandlers() to add the necessary event handlers for each button.
//
// element: DOM element to add event listeners to
// overImage: mouseover image to show
// downImage: mousedown image to show
//
function addHilightListeners(element, overImage, downImage)
{
    var offImage = new Image();
    offImage.src = element.src;

    element.addEventListener("mouseover", function () { swapImage(element, overImage) }, true);
    element.addEventListener("mousedown", function () { swapImage(element, downImage) }, true);
    element.addEventListener("mouseup", function () { swapImage(element, overImage) }, true);
    element.addEventListener("mouseout", function () { swapImage(element, offImage) }, true);
}

//
// Function: swapImage(element, image)
// Show a new image in a DOM image element
//
// element: Image element to change
// image: Image to show
//
function swapImage(element, image)
{
    element.src = image.src;
}

//
// Function: clickOnLink()
// Called from onClick to open a link in the browser instead of in the widget.
//
function clickOnLink()
{
    if (window.widget) {
        widget.openURL(this.href);
        return false;
    }
}

// ***************************************************************************************************


//
// Function: showPrevEntry(event)
// Called by the back button to show the previous entry.
//
// event: onClick event from widget.
//
function showPrevEntry(event)
{
    if (entries && entries.length) {
        if (--currentEntry < 0) {
            currentEntry = entries.length-1;
        }
        showEntry(currentEntry);
    }
}

//
// Function: showNextEntry(event)
// Called by the forward button to show the next entry.
//
// event: onClick event from widget.
//
function showNextEntry(event)
{
    if (entries && entries.length && currentEntry < entries.length) {
        if (++currentEntry >= entries.length) {
            currentEntry = 0;
        }

        showEntry(currentEntry);
    }
}

//
// Function: keyPressed(event)
// Handler to allow back and forward from the keyboard.
//
// event: onClick event from widget.
//
function keyPressed(event)
{
    switch (event.keyIdentifier) {
        case "Left":
            showPrevEntry();
            break;
        case "Right":
            showNextEntry();
            break;
		//case "Up":
		//	showHideEpisodeDetailBox();
		//	break;
		//case "Down":
		//	showHideEpisodeDetailBox();
        //default:
        //    return;
		default: break;
    }

    event.stopPropagation();
    event.preventDefault();
}

//
// Function: load()
// Called by HTML body element's onload event when the widget is ready to start
//
function load()
{

    dashcode.setupParts();
    setupHandlers();
    hideElement("backButton");
    hideElement("forwardButton");
    document.addEventListener("keypress", keyPressed, true);

    entries = new Array();

    clearContent();
    refreshFeed();
}

// ***************************************************************************************************
//
// Function: remove()
// Called when the widget has been removed from the Dashboard
//
function remove()
{
    // Stop any timers to prevent CPU usage
    // Remove any preferences as needed
    // widget.setPreferenceForKey(null, dashcode.createInstancePreferenceKey("your-key"));
}

//
// Function: hide()
// Called when the widget has been hidden
//
function hide()
{
    // Stop any timers to prevent CPU usage
}

//
// Function: show()
// Called when the widget has been shown
//
function show()
{
    // Refresh feed if 15 minutes have passed since the last update
    var now = (new Date).getTime();
    if ((now - lastUpdated) > 15 * 60 * 1000) {
        refreshFeed();
    }
}

//
// Function: sync()
// Called when the widget has been synchronized with .Mac
//
function sync()
{
    // Retrieve any preference values that you need to be synchronized here
    // Use this for an instance key's value:
    // instancePreferenceValue = widget.preferenceForKey(null, dashcode.createInstancePreferenceKey("your-key"));
    //
    // Or this for global key's value:
    // globalPreferenceValue = widget.preferenceForKey(null, "your-key");
}
// Initialize the Dashboard event handlers
if (window.widget) {
    widget.onremove = remove;
    widget.onhide = hide;
    widget.onshow = show;
    widget.onsync = sync;
}




// ***************************************************************************************************

function showHideEpisodeDetailBox(event)
{
  
	var duration = 500;						
	var interval = 13;
	var startingVal = (showingDetailView == true)?1.0:0.0;
	var finishingVal = (showingDetailView == true)?0.0:1.0;
	
	showingDetailView = !showingDetailView;
	
	var itemToFadeInOut = document.getElementById("epDetailBox");
	
	if(itemToFadeInOut.style.visibility != "visible"){
		//this will make appear the object for the first time. (If is visible from the beggining it will fail)
		itemToFadeInOut.style.opacity = 0.0;
		itemToFadeInOut.style.visibility = "visible";
		itemToFadeInOut.style.backgroundColor = "rgba(255, 255, 255, 0.589844)"; 
	
		
	}
	
	var fadeHandler = function(a, c, s, f){ itemToFadeInOut.style.opacity = c; };
	new AppleAnimator(duration, interval, startingVal, finishingVal, fadeHandler).start();
	
}
function openLink(url){
    if (window.widget) {
        widget.openURL(url);
        return false;
    }
}
function openWikipedia(event)
{
    openLink("http://en.wikipedia.org/wiki/List_of_Naruto:_Shippuden_episodes");
}
function openNacho4d(event)
{
    openLink("http://web.me.com/nacho4d/");
}
function openMailNacho4d(event)
{
    openLink("mailto:nacho4d@gmail.com?subject=Regarding 'Naruto Shippuden Episode List' Widget");
}
function showBack(event)
{
    var front = document.getElementById("front");
    var back = document.getElementById("back");

    if (window.widget) {
        widget.prepareForTransition("ToBack");
    }

    front.style.display="none";
    back.style.display="block";

    if (window.widget) {
        setTimeout("widget.performTransition();", 0);
    }
}

function showFront(event)
{
    var front = document.getElementById("front");
    var back = document.getElementById("back");

    if (window.widget) {
        widget.prepareForTransition("ToFront");
    }

    front.style.display = "block";
    back.style.display = "none";

    if (window.widget) {
        setTimeout("widget.performTransition();", 0);
    }
}
